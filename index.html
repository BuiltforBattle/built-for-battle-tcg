<!DOCTYPE html>
<html lang="en">
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
<script>
  const supabase = supabase.createClient(
    'https://dlmivckwqxkkbsysnfzy.supabase.co', // üëà paste your Project URL here
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRsbWl2Y2t3cXhra2JzeXNuZnp5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY0NDc0NDUsImV4cCI6MjA2MjAyMzQ0NX0.DOeGI6BlgAoHQYlD3anHYCTH_TG4_snHegKDW5LvMTw' // üëà paste your public API key here
  );
</script>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DUAL BATTLE</title>
  <style>
  body {
	font-family: 'Segoe UI', sans-serif;
	background: url('https://static.wixstatic.com/media/7f810a_5d9de97cffb54565b523e87a29212131~mv2.png') no-repeat center center fixed;
	background-size: cover;
	background-color: #1c1c1c;
	color: #f4f4f4;
	text-align: center;
	padding: 20px;
	min-height: 100vh;
	display: flex;
	flex-direction: column;
	justify-content: center;
  }

  body.setup-only {
    overflow: hidden;
}

  body.normal-scroll {
    overflow-y: auto;
    overflow-x: hidden;
}

  .screen {
	max-width: 600px;
	margin: auto;
	background: rgba(0, 0, 0, 0.75); /* darker transparent background */
	padding: 30px 20px;
	border-radius: 15px;
	box-shadow: 0 0 20px rgba(230, 36, 41, 0.7);
	backdrop-filter: blur(6px); /* nice blur effect */
  }
  input[type="text"], input[type="number"], select {
	width: 80%;
	padding: 10px;
	font-size: 1em;
	margin: 10px 0;
	border-radius: 5px;
	border: none;
  }
  button {
	padding: 10px 20px;
	font-size: 1em;
	margin-top: 20px;
	background-color: #e62429;
	color: white;
	border: none;
	border-radius: 5px;
	cursor: pointer;
  }
  .radio-group {
	display: flex;
	justify-content: center;
	gap: 20px;
	margin-top: 10px;
  }
  label {
	font-size: 1em;
  }
  .card-entry {
	background: rgba(60, 60, 60, 0.9);
	margin: 10px auto;
	padding: 10px;
	border-radius: 8px;
  }
  .active-card {
  }
  #playerCards span[id^="hpDisplay"] {
  font-size: 2em;
  font-weight: bold;
  color: #ffffff;
}
  button.player1 {
  background-color: #e62429; /* Red */
}

  button.player2 {
  background-color: #007bff; /* Blue */
}
  .color-preview {
	display: inline-block;
	width: 10px;
	height: 10px;
	border-radius: 50%;
	margin-left: 5px;
  }
  a {
	color: #00f2ff;
	text-decoration: underline;
  }
  @keyframes goldFlash {
  0% { color: gold; text-shadow: 0 0 5px gold; }
  50% { color: white; text-shadow: 0 0 15px gold; }
  100% { color: gold; text-shadow: 0 0 5px gold; }
}

.flash-gold {
  animation: goldFlash 1.5s infinite;
}

.defeated-stamp {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) rotate(-15deg);
  font-size: 1.8em;
  color: #ff3333;
  font-weight: bold;
  background: rgba(255, 255, 255, 0.2); /* üî• dark background behind the text */
  padding: 8px 12px;
  border-radius: 10px;
  opacity: 1;
  pointer-events: none;
  animation: defeatedFlash 1.5s infinite;
  z-index: 2;
}

@keyframes defeatedFlash {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 0.3; }
}

.defeated-card {
  filter: grayscale(0%);
  position: relative;
}

.defeated-card::after {
  content: '';
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0, 0, 0, 0.4); /* dark overlay */
  z-index: 1;
  pointer-events: none;
}

@keyframes flashGreen {
  0% { background-color: #28a745; }
  50% { background-color: #34d058; }
  100% { background-color: #28a745; }
}

.flash-green {
  animation: flashGreen 1s ease;
}

.active-card-container {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 20px;
  flex-wrap: wrap;
  padding: 20px 10px;
}

.active-card-image {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
}
    
.active-card-image img {
  max-width: 80%;
  border-radius: 10px;
}

.active-card-info {
  flex: 1;
  min-width: 200px;
  text-align: center; /* üî• Center everything inside */
}
.active-card-info h4,
.active-card-info p {
  margin: 5px 0;
  text-align: center;
}

@media (max-width: 600px) {
  .screen {
    margin: 20px auto;
    padding: 20px 15px;
  }

  #gameplayScreen {
    margin-left: auto;
    margin-right: auto;
    width: 90%;
    max-width: 600px;
  }

  .active-card-container {
    flex-direction: column;
    align-items: center;
    margin-top: 20px;
  }

  #roundTracker {
    margin-top: 5px !important;
    margin-bottom: 5px !important;
  }
}
    
.active-card-info {
    text-align: center;
  }
}

.button-group {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 5px; /* üî• tighter spacing */
  margin: 5px 0;
}

@keyframes redPulse {
  0% { box-shadow: 0 0 10px #e62429; }
  50% { box-shadow: 0 0 20px #e62429; }
  100% { box-shadow: 0 0 10px #e62429; }
}

@keyframes bluePulse {
  0% { box-shadow: 0 0 10px #007bff; }
  50% { box-shadow: 0 0 20px #007bff; }
  100% { box-shadow: 0 0 10px #007bff; }
}

.red-pulse {
  animation: redPulse 2s infinite;
}

.blue-pulse {
  animation: bluePulse 2s infinite;
}

#imageModal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.85);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  cursor: pointer;
}

#imageModal img {
  max-width: 90%;
  max-height: 90%;
  border-radius: 10px;
  box-shadow: 0 0 20px #fff;
}

  </style>
</head>
<body class="setup-only">
  <div class="screen" id="setupScreen">
	<img src="https://static.wixstatic.com/media/7f810a_210d5ec4c8f34517b7eaf24df4658344~mv2.png" alt="Built for Battle Logo" style="max-width: 200px; margin-bottom: 20px;">
	<h1>DUAL BATTLE</h1>
	<h2>Pre-Game Setup</h2>
	<div class="radio-group">
    <label><input type="radio" name="matchMode" value="create" checked> Create Match</label>
    <label><input type="radio" name="matchMode" value="join"> Join Match</label>
    </div>
    
    <input type="text" id="player1Name" placeholder="Enter Player 1 Name">
	<input type="text" id="player2Name" placeholder="Enter Player 2 Name">

    <div style="text-align: center; margin: 10px 0;">
    <input type="text" id="matchIdInput" placeholder="Enter Match ID to Join" style="display:none; width: 80%; max-width: 300px; margin: 0 auto;">
    </div>


	<div>
  	<p>Who goes first?</p>
  	<div class="radio-group">
    	<label><input type="radio" name="firstTurn" value="1"> Player 1</label>
    	<label><input type="radio" name="firstTurn" value="2"> Player 2</label>
  	</div>
	</div>

	<button onclick="startMatch()">Start Match</button>
	<div style="margin-top: 40px; font-size: 0.9em;">
      <p id="matchCodeDisplay" class="flash-gold" style="margin-bottom: 10px;"></p>
      <button onclick="copyMatchId()" style="margin-top: 10px;">Copy Match ID</button><br>
      <a href="https://www.builtforbattleleague.com/tcg-rules" target="_blank">View Official Game Rules</a>
    </div>

    <script>
    
    // SUPABASE AND MATCH LOGIC
      
    async function startMatch() {
      const p1 = document.getElementById('player1Name').value.trim();
      const p2 = document.getElementById('player2Name').value.trim();
      const first = document.querySelector('input[name="firstTurn"]:checked');
      const matchMode = document.querySelector('input[name="matchMode"]:checked').value;

      if (!p1 || !p2 || !first) {
        showMessage("Please enter both player names and select who goes first.");
        return;
      }

      player1 = p1;
      player2 = p2;
      startingPlayer = parseInt(first.value);

      if (matchMode === "join") {
        const matchId = document.getElementById('matchIdInput').value.trim();
        if (!matchId) {
          showMessage("Please enter a Match ID to join.");
          return;
        }

        const { data, error } = await supabase
          .from("matches")
          .select("*")
          .eq("id", matchId)
          .single();

        if (error || !data) {
          showMessage("Match not found. Please check the ID.");
          return;
        }

        window.matchId = matchId;
        teamData = data.team_data;
        stats = data.stats;
        roundWinners = data.round_winners;
        currentTurn = data.current_turn;
        currentRound = data.current_round;
        matchOver = data.match_over;

        subscribeToMatchUpdates(matchId);
      } else {
        const { data, error } = await supabase
          .from("matches")
          .insert([{
            team_data: teamData,
            stats: stats,
            round_winners: roundWinners,
            current_turn: startingPlayer,
            current_round: 1,
            match_over: false
          }])
          .select()
          .single();

        console.log("Returned Supabase Data:", data);
        console.log("Returned Supabase Error:", error);
        
        if (error) {
          showMessage("Failed to create match.");
          return;
        }

        window.matchId = data.id;
        subscribeToMatchUpdates(data.id);
        document.getElementById('matchCodeDisplay').innerText = `Match ID: ${data.id}`;
      }

  // ‚úÖ Move to gameplay screen after either create or join
      document.getElementById('setupScreen').style.display = 'none';
      document.body.classList.remove('setup-only');
      document.body.classList.add('normal-scroll');
      showGameplayScreen();
    }

  
      
    async function syncMatchToSupabase() {
      if (!window.matchId) {
        console.warn("No match ID available. Sync aborted.");
        return;
      }

      const { error } = await supabase
        .from('matches')
        .update({
          team_data: teamData,
          stats: stats,
          round_winners: roundWinners,
          current_turn: currentTurn,
          current_round: currentRound,
          match_over: matchOver
        })
        .eq('id', window.matchId);

      if (error) {
        console.error("‚ùå Error syncing match data:", error.message);
        showMessage("Failed to sync match data to server.");
      } else {
        console.log("‚úÖ Match data synced successfully.");
      }
    }


    function subscribeToMatchUpdates(matchId) {
      supabase
        .channel('match-updates')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'matches',
            filter: `id=eq.${matchId}`
          },
          payload => {
            const match = payload.new;

            if (match) {
              // Update local match state
              teamData = match.team_data;
              stats = match.stats;
              roundWinners = match.round_winners;
              currentTurn = match.current_turn;
              currentRound = match.current_round;
              matchOver = match.match_over;

              updateGameplayView(); // Redraw screen with updated data
            }
          }
        )
        .subscribe();
    }  

      
    function copyMatchId() {
      const text = document.getElementById('matchCodeDisplay').innerText.replace('Match ID: ', '').trim();
      if (!text) {
        showMessage("No Match ID to copy yet.");
        return;
      }

      navigator.clipboard.writeText(text).then(() => {
        showMessage("Match ID copied to clipboard!");
      }).catch(() => {
        showMessage("Failed to copy Match ID.");
      });
    }  

      
    function showMessage(text) {
      const messageDiv = document.getElementById('gameMessage');
      if (messageDiv) {
        messageDiv.innerText = text;

        setTimeout(() => {
          messageDiv.innerText = '';
        }, 4000);
      } else {
        alert(text); // üî• Fallback if gameMessage div is not present yet
      }
    }

    // GAME SETUP AND GLOBAL STATE
      
    teamData[1] = [
      { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false },
      { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false },
      { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false },
      { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false }
    ];
    teamData[2] = [
      { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false },
      { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false },
      { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false },
      { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false }
    ];
    
      
    document.querySelectorAll('input[name="matchMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        const mode = document.querySelector('input[name="matchMode"]:checked').value;
        document.getElementById('matchIdInput').style.display = (mode === 'join') ? 'block' : 'none';
      });
    });
 
	let player1 = "";
	let player2 = "";
	let startingPlayer = 1;
	let teamData = { 1: [], 2: [] };
	let currentSetupPlayer = 1;
    let roundWinners = ["Pending", "Pending", "Pending"];
    let stats = {
      1: { attacks: 0, totalDamage: 0, defenses: 0, abilities: 0, diceRolls: 0 },
      2: { attacks: 0, totalDamage: 0, defenses: 0, abilities: 0, diceRolls: 0 }
    };
      
    const availableCards = [
      { name: "Bearded_Tattooed_Guy_In_GA", hp: 120, img: "https://static.wixstatic.com/media/7f810a_47547269f9a442c1be542386b9a95dbc~mv2.jpg" },
      { name: "IGHatesChazzy", hp: 130, img: "https://static.wixstatic.com/media/7f810a_75fb02ccb3ee4229b445beafbfdba4b6~mv2.jpg" },
      { name: "J9lives", hp: 120, img: "https://static.wixstatic.com/media/7f810a_954adcda70fe42259852a029221f0451~mv2.jpg" },
      { name: "KiraKreates", hp: 100, img: "https://static.wixstatic.com/media/7f810a_f63e3610f25d44709d0e1817c2a87b68~mv2.jpg" },
      { name: "KosplayKreationz", hp: 150, img: "https://static.wixstatic.com/media/7f810a_8bfa55f15aca4cfea19228a985d7108f~mv2.jpg" },
      { name: "Num1xmncosplay", hp: 100, img: "https://static.wixstatic.com/media/7f810a_8c2b3ee0b445415da52259e9dccb8fcb~mv2.jpg" },
      { name: "Paper.Moon.Cosplay", hp: 120, img: "https://static.wixstatic.com/media/7f810a_db8d11a28246466e91097443dbeafa18~mv2.jpg" },
      { name: "ParadoxxCosplay", hp: 185, img: "https://static.wixstatic.com/media/7f810a_18bae39081b948f4aa2405dd42878bc9~mv2.jpg" },
      { name: "The_Googinator", hp: 100, img: "https://static.wixstatic.com/media/7f810a_a78a4a761d38467cb4166dad685918d5~mv2.jpg" },
      { name: "TStunningTyler", hp: 130, img: "https://static.wixstatic.com/media/7f810a_5c32325c34be479f97213b31611224d5~mv2.jpg" }
      // üî• Add more here easily anytime!
    ];

// GAME FLOW LOGIC
      
function showGameplayScreen() {
  currentTurn = startingPlayer;
  document.getElementById('gameplayScreen').style.display = 'block';
  updateGameplayView();
}

function updateGameplayView() {
  hasSwappedThisTurn = false;
  const player = currentTurn;
  const playerName = player === 1 ? player1 : player2;
  // Update Round Tracker
let trackerHTML = "<h3>Round Results:</h3><p>";
for (let i = 0; i < 3; i++) {
  if (roundWinners[i] === "Pending") {
    trackerHTML += `Round ${i + 1}: Pending ‚è≥`;
  } else {
    trackerHTML += `Round ${i + 1}: ${roundWinners[i]} (Win)`;
  }
  if (i < 2) trackerHTML += " | ";
}
trackerHTML += "</p>";
document.getElementById('roundTracker').innerHTML = trackerHTML;
  document.getElementById('turnTitle').innerText = `Round ${currentRound} - ${playerName}'s Turn`;
  const cardArea = document.getElementById('playerCards');
  cardArea.innerHTML = '';

  const activeCard = teamData[player].find(card => card.active);
  const benchedCards = teamData[player].map((card, i) => ({ ...card, originalIndex: i })).filter(card => !card.active);
  const screen = document.querySelector('.screen');
	screen.style.boxShadow = player === 1
  	? '0 0 20px rgba(230, 36, 41, 0.7)'  // Red for Player 1
  	: '0 0 20px rgba(0, 123, 255, 0.7)'; // Blue for Player 2

 
  if (activeCard) {
  const i = teamData[player].indexOf(activeCard);
  cardArea.innerHTML += `
	<h3 style='margin-bottom: 10px; border-bottom: 1px solid #e62429; padding-bottom: 5px;'>Active Player Area</h3>
  <div class="active-card-container" style="border: 2px solid ${player === 1 ? '#e62429' : '#007bff'}; box-shadow: 0 0 15px ${player === 1 ? '#e62429' : '#007bff'};">
    <div class="active-card-image">
      ${activeCard.img ? `<img src="${activeCard.img}" alt="${activeCard.name}" onclick="enlargeImage('${activeCard.img}')" class="${player === 1 ? 'red-pulse' : 'blue-pulse'}">` : ''}
    </div>
    <div class="active-card-info">
      <h4>${activeCard.name} (Slot ${i + 1})</h4>
      <p>HP: <span id="hpDisplay${i}">${activeCard.hp}</span></p>
      ${activeCard.defense > 0 ? `<p>Defense: ${activeCard.defense} üõ°Ô∏è</p>` : ''}
 	 
    <div class="button-group">
     	<button class="${player === 1 ? 'player1' : 'player2'}" onclick="adjustHP(${player}, ${i}, 10)">+10</button>
     	<button class="${player === 1 ? 'player1' : 'player2'}" onclick="adjustHP(${player}, ${i}, 5)">+5</button>
     	<button class="${player === 1 ? 'player1' : 'player2'}" onclick="adjustHP(${player}, ${i}, -5)">-5</button>
     	<button class="${player === 1 ? 'player1' : 'player2'}" onclick="adjustHP(${player}, ${i}, -10)">-10</button>
  	</div>

  	<div class="button-group">
    	<button class="${player === 1 ? 'player1' : 'player2'}" onclick="activateDefense()">Defend</button>
    	<button class="${player === 1 ? 'player1' : 'player2'}" onclick="defenseBreak()">Defense Break</button>
  	</div>

  	<div class="button-group">
        <input type="number" id="attackInput${i}" placeholder="Attack Amount" style="width: 100px;">
        <button class="${player === 1 ? 'player1' : 'player2'}" onclick="quickAttack(${i}, 25)">+25</button>
        <button class="${player === 1 ? 'player1' : 'player2'}" onclick="performAttack(${i})">Attack</button>
    </div>


  	<div class="button-group">
    	<select id="diceOutcomeSelect" style="padding: 8px; width: 200px;">
      	<option value="">Dice Roll Outcome</option>
      	<option value="1">1 - Health Gain (+10 HP All Cards)</option>
      	<option value="2">2 - Health Lost (-10 HP Opponent Cards)</option>
      	<option value="3">3 - Defense Break (-10 Opponent Defense)</option>
      	<option value="4">4 - Defense Gain (+10 Defense Active)</option>
      	<option value="5">5 - Attack Swap (Use Opponent Basic Attack)</option>
      	<option value="6">6 - Power Attack (Use Special Attack Free)</option>
  	</select>
    	<button class="${player === 1 ? 'player1' : 'player2'}" onclick="applyDiceOutcome()">Apply Dice Outcome</button>
  	</div>

    <div class="button-group">
      <button id="abilityButton" class="${player === 1 ? 'player1' : 'player2'}" onclick="activateAbility()" ${activeCard.abilityUsed ? 'disabled' : ''}>
        Activate Ability
      </button>
    </div>

  	<div class="button-group">
    	<button class="${player === 1 ? 'player1' : 'player2'}" onclick="endTurn()">End Turn</button>
  	</div>

  	<p>Color: ${activeCard.color || 'None'} ${activeCard.played ? '<span style="color: orange; font-weight: bold;">(Played)</span>' : ''}</p>
	</div>
	<hr style='border: 1px solid white; width: 90%; margin: 40px auto;'>
    </div>
</div>
  `;
    
}

  cardArea.innerHTML += `<h3 style='margin: 40px 0 10px 0; border-bottom: 1px solid #ccc; padding-bottom: 5px;'>Benched Player Area</h3>`;
  benchedCards.forEach(card => {
  const i = card.originalIndex;
  cardArea.innerHTML += `
    <div class="card-entry ${card.hp <= 0 ? 'defeated-card' : ''}" id="card${i}" style="border: 2px solid ${card.color || '#cccccc'}; box-shadow: 0 0 10px ${card.color || '#cccccc'}; background: ${!card.played ? 'rgba(100,100,100,0.5)' : 'rgba(60,60,60,0.9)'};">
      ${card.hp <= 0 ? '<div class="defeated-stamp">DEFEATED</div>' : ''}
      
      <div class="active-card-container">
        <div class="active-card-image">
          ${
            !card.played
              ? `<img src="https://static.wixstatic.com/media/7f810a_18401a2529594f189b64c4680a19c0a4~mv2.png" alt="Card Back" style="max-width:80%; border-radius:10px;">`
              : `${card.img ? `<img src="${card.img}" alt="${card.name}" style="max-width:80%; border-radius:10px;">` : ''}`
          }
        </div>

        <div class="active-card-info">
          <h4>Benched Player (Slot ${i + 1}) ${!card.played ? '<span style="font-size: 0.8em; color: #ccc;">(Face Down)</span>' : ''}</h4>

          ${!card.played ? `
            <select onchange="selectCard(${player}, ${i}, this.value)">
              <option value="">Select Character</option>
              ${availableCards.map(c => `<option value="${c.name}">${c.name} (HP: ${c.hp})</option>`).join('')}
            </select>
            <input type="text" id="nameInput${player}_${i}" value="${card.name}" onchange="updateCardName(${player}, ${i}, this.value)">
            <input type="number" id="hpInput${player}_${i}" value="${card.hp}" onchange="updateCardHP(${player}, ${i}, this.value)">
            <select id="colorInput${player}_${i}" onchange="updateCardColor(${player}, ${i}, this.value)">
              <option value="">‚ö™ No Color</option>
              <option value="red">üî¥ Red</option>
              <option value="blue">üîµ Blue</option>
              <option value="green">üü¢ Green</option>
              <option value="yellow">üü° Yellow</option>
            </select>
          ` : `
            <h4>${card.name}</h4>
            <p>HP: <span id="hpDisplay${i}">${card.hp}</span></p>
          `}
          
          <p>Color: ${card.color || 'None'} ${card.played ? '<span style="color: orange; font-weight: bold;">(Played)</span>' : ''}</p>

          ${!activeCard ? `
            ${card.hp > 0 ? `<button onclick="setActiveCard(${i})">Set Active</button>` : ''}
          ` : `
            <button onclick="swapCard(${i})">Swap</button>
            ${!card.played ? `<button onclick="replaceWithNewCard(${i})">Swap with New Card</button>` : ''}
          `}
        </div>
      </div>
    </div>
  `;
});
}

function endTurn() {
  if (matchOver) return;
  currentTurn = currentTurn === 1 ? 2 : 1;
  const hasActive = teamData[currentTurn].some(card => card.active && card.hp > 0);

  if (!hasActive) {
  showMessage("No Active Card! Please select a new Active Player.");
  }
  syncMatchToSupabase();
  updateGameplayView();
}
      
function endRound() {
  let selectedResult = document.querySelector('input[name="roundResult"]:checked');
  if (selectedResult) {
    roundResults[currentRound - 1] = selectedResult.value === "win" ? "Win" : "Loss";
    
    if (selectedResult.value === "win") {
      roundWinners[currentRound - 1] = currentTurn === 1 ? player1 : player2;
    } else if (selectedResult.value === "lose") {
      roundWinners[currentRound - 1] = currentTurn === 1 ? player2 : player1;
    }
    // üî• Set who goes first in the next round
    if (selectedResult.value === "win") {
      startingPlayer = currentTurn; // Winner goes first next round
    } else {
      startingPlayer = currentTurn === 1 ? 2 : 1; // If lost, opponent goes first
    }
  }

  // üõ°Ô∏è New code: Check wins immediately
  let player1Wins = 0;
  let player2Wins = 0;
  for (let i = 0; i < 3; i++) {
    if (roundWinners[i] === player1) player1Wins++;
    if (roundWinners[i] === player2) player2Wins++;
  }

  if (player1Wins === 2 || player2Wins === 2 || currentRound === 3) {
    declareWinner();
    return; // üî• Stop here, no more rounds
  }

  // If not ended, continue normally
  currentRound++;
teamData[1] = [
  { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false },
  { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false },
  { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false },
  { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false }
];
teamData[2] = [
  { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false },
  { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false },
  { name: "", hp: 100, color: "", active: false, played: false, defense: 0, abilityUsed: false }
];

document.getElementById('gameplayScreen').style.display = 'block';
syncMatchToSupabase();
updateGameplayView();
}

function declareWinner() {
  let player1Wins = 0;
  let player2Wins = 0;

  for (let i = 0; i < 3; i++) {
    if (roundWinners[i] === player1) player1Wins++;
    if (roundWinners[i] === player2) player2Wins++;
  }

  let winnerName = "";
  if (player1Wins > player2Wins) {
    winnerName = player1;
  } else if (player2Wins > player1Wins) {
    winnerName = player2;
  } else {
    winnerName = "It's a Tie!";
  }

  // Hide gameplay, show winner screen
  document.getElementById('gameplayScreen').style.display = 'none';
  document.getElementById('winnerScreen').style.display = 'block';

  // Update final winner name
  document.getElementById('finalWinnerName').innerText = `Winner: ${winnerName}`;
  document.getElementById('finalWinnerName').classList.add('flash-gold');

  // Build round results nicely
  let resultsHTML = "<h3>Round Results:</h3><ul>";
  for (let i = 0; i < 3; i++) {
    resultsHTML += `<li>Round ${i + 1}: ${roundWinners[i]}</li>`;
  }
  resultsHTML += "</ul>";
  document.getElementById('finalRoundResults').innerHTML = resultsHTML;

  matchOver = true;
}

function showMatchSummary() {
  document.getElementById('winnerScreen').style.display = 'none';
  document.getElementById('matchSummaryScreen').style.display = 'block';

  let summaryHTML = `
    <h2>${player1} vs ${player2}</h2>
    <h3>Final Winner: ${document.getElementById('finalWinnerName').innerText.replace('Winner: ', '')}</h3>
    <h3>Round Results:</h3>
    <ul>
      <li>Round 1: ${roundWinners[0]}</li>
      <li>Round 2: ${roundWinners[1]}</li>
      <li>Round 3: ${roundWinners[2]}</li>
    </ul>
    <h3>Battle Stats:</h3>
    <div style="text-align:left;">
      <h4>${player1}:</h4>
      <ul>
        <li>‚öîÔ∏è Attacks Used: ${stats[1].attacks}</li>
        <li>üí• Total Damage Dealt: ${stats[1].totalDamage}</li>
        <li>üõ°Ô∏è Defenses Used: ${stats[1].defenses}</li>
        <li>‚ú® Abilities Activated: ${stats[1].abilities}</li>
        <li>üé≤ Dice Rolls Used: ${stats[1].diceRolls}</li>
      </ul>
      <h4>${player2}:</h4>
      <ul>
        <li>‚öîÔ∏è Attacks Used: ${stats[2].attacks}</li>
        <li>üí• Total Damage Dealt: ${stats[2].totalDamage}</li>
        <li>üõ°Ô∏è Defenses Used: ${stats[2].defenses}</li>
        <li>‚ú® Abilities Activated: ${stats[2].abilities}</li>
        <li>üé≤ Dice Rolls Used: ${stats[2].diceRolls}</li>
      </ul>
    </div>
  `;

  document.getElementById('matchSummaryContent').innerHTML = summaryHTML;
}

function endMatch() {
  location.reload();
}

// CARD MANAGEMENT
      
function adjustHP(player, index, amount) {
  if (matchOver) return;
  teamData[player][index].hp = Math.max(0, teamData[player][index].hp + amount);
  document.getElementById(`hpDisplay${index}`).innerText = teamData[player][index].hp;
  syncMatchToSupabase();
}
      
function updateCardName(player, index, newName) {
  teamData[player][index].name = newName.trim();
}

function updateCardHP(player, index, newHP) {
  const value = parseInt(newHP);
  if (!isNaN(value)) {
	teamData[player][index].hp = value;
	const hpDisplay = document.getElementById(`hpDisplay${index}`);
	if (hpDisplay) hpDisplay.innerText = value;
  }
}

function updateCardColor(player, index, newColor) {
  teamData[player][index].color = newColor;
  updateGameplayView();
}

function selectCard(player, index, selectedName) {
  const selected = availableCards.find(c => c.name === selectedName);
  if (selected) {
    teamData[player][index].name = selected.name;
    teamData[player][index].hp = selected.hp;
    teamData[player][index].img = selected.img || ""; // Save the image if available
    
    document.getElementById(`nameInput${player}_${index}`).value = selected.name;
    document.getElementById(`hpInput${player}_${index}`).value = selected.hp;
    syncMatchToSupabase();
    updateGameplayView();
  }
}

function replaceWithNewCard(index) {
  if (matchOver) return;
  const newName = prompt("Enter the new Player Card name:");
  if (!newName) return;

  const newHP = prompt("Enter starting HP for this card:", "100");
  const hpValue = parseInt(newHP);
  if (isNaN(hpValue)) {
	showMessage("Invalid HP value.");
	return;
  }
 
  const oldColor = teamData[currentTurn][index].color;

  teamData[currentTurn][index] = {
	name: newName,
    hp: hpValue,
    color: oldColor,
    active: false,
    played: false,
    defense: 0,
    abilityUsed: false,
    img: "" // or let user choose later
  };
  syncMatchToSupabase();
  updateGameplayView();
}

function setActiveCard(index) {
  if (matchOver) return;
  
  teamData[currentTurn].forEach((card, i) => {
    card.active = i === index;
    if (card.active) card.played = true;
  });
  syncMatchToSupabase();
  
  if (!bothPlayersHaveActive()) {
    // If the other player hasn't chosen their Active Player yet
    endTurn(); // Immediately pass the turn
  } else {
    // Both players now have Active Cards ‚Äî force currentTurn to startingPlayer
    currentTurn = startingPlayer;
    updateGameplayView();
  }
}

function bothPlayersHaveActive() {
  const p1Active = teamData[1].some(card => card.active);
  const p2Active = teamData[2].some(card => card.active);
  return p1Active && p2Active;
}
       
function swapCard(index) {
  if (matchOver) return;

  const activeIndex = teamData[currentTurn].findIndex(card => card.active);
  const activeCard = teamData[currentTurn][activeIndex];
  const benchedCard = teamData[currentTurn][index];

  if (benchedCard.hp <= 0) {
    showMessage("This card has been defeated and cannot be swapped in.");
    return;
  }

  if (hasSwappedThisTurn) {
    showMessage("You have already swapped this turn.");
    return;
  }

  hasSwappedThisTurn = true;
  showMessage("Swapped! Turn ended automatically.");

  // Swap active status
  teamData[currentTurn].forEach(card => card.active = false);
  teamData[currentTurn][index].active = true;
  teamData[currentTurn][index].played = true;
  
  endTurn(); // End turn after swap
  syncMatchToSupabase();
}

// COMBAT AND EFFECTS
      
function performAttack(i) {
  if (matchOver) return;
  const input = document.getElementById(`attackInput${i}`);
  const damage = parseInt(input.value);
  if (!isNaN(damage) && damage > 0) {
  stats[currentTurn].attacks++; // <-- MOVE THIS HERE
  attackOpponent(damage);
  input.value = '';
  } else {
  showMessage("Enter a valid attack amount!");
  }
}

function quickAttack(index, amount) {
  if (matchOver) return;
  const input = document.getElementById(`attackInput${index}`);
  if (input) {
    input.value = amount;
  }
}
  
function attackOpponent(damageAmount) {
  if (matchOver) return;
  const opponent = currentTurn === 1 ? 2 : 1;
  const activeCard = teamData[opponent].find(card => card.active);
  if (activeCard) {
	let effectiveDamage = damageAmount;

  if (activeCard.defense > 0) {
    effectiveDamage = Math.max(0, damageAmount - activeCard.defense);
  	activeCard.defense = 0; // Defense is used up after blocking
	}

	activeCard.hp = Math.max(0, activeCard.hp - effectiveDamage);
    stats[currentTurn].totalDamage += effectiveDamage;
    syncMatchToSupabase();
    
  if (effectiveDamage > 0) {
      showMessage(`üí• Attack successful! Dealt ${effectiveDamage} damage to ${activeCard.name}.`);
    } else {
      showMessage(`üõ°Ô∏è Attack blocked! ${activeCard.name} took no damage.`);
    }

  if (activeCard.hp === 0) {
    activeCard.active = false; // Auto remove active status if defeated
    showMessage(`${activeCard.name} has been defeated!`);
  }
  const allDefeated = teamData[opponent].every(card => card.hp <= 0);

  if (allDefeated) {
  showMessage(`${currentTurn === 1 ? player1 : player2} wins the round by defeating all opponent cards!`);
  
  // Auto-select Win
  document.querySelector('input[name="roundResult"][value="win"]').checked = true;
  endRound();
  }
    updateGameplayView();
  }
}

function activateDefense() {
  if (matchOver) return;
  const activeCard = teamData[currentTurn].find(card => card.active);
  if (activeCard) {
	activeCard.defense += 10; // You can stack the amount
	showMessage(`${activeCard.name} is now defending (+10)!`);
	stats[currentTurn].defenses++;
    syncMatchToSupabase();
    updateGameplayView();
  }
}

function defenseBreak() {
  if (matchOver) return;
 
  const opponent = currentTurn === 1 ? 2 : 1;
  const activeCard = teamData[opponent].find(card => card.active);
 
  if (activeCard) {
	if (activeCard.defense > 0) {
  	activeCard.defense = Math.max(0, activeCard.defense - 10); // Lower defense by 10
  	showMessage(`Defense Break successful! ${activeCard.name}'s defense was reduced by 10.`);
	} else {
  	showMessage(`No active defense to break on ${activeCard.name}.`);
	}
    syncMatchToSupabase();
	updateGameplayView();
  }
}

function activateAbility() {
  if (matchOver) return;
  const activeCard = teamData[currentTurn].find(card => card.active);

  if (activeCard && !activeCard.abilityUsed) {
    activeCard.abilityUsed = true;
    showMessage(`${activeCard.name} activated their Ability!`);

    // Find and animate the Ability button
    const abilityBtn = document.getElementById('abilityButton');
    if (abilityBtn) {
      abilityBtn.classList.add('flash-green');
      setTimeout(() => {
        abilityBtn.classList.remove('flash-green');
      }, 1000); // Remove after animation
    }
    stats[currentTurn].abilities++;
    syncMatchToSupabase();
    updateGameplayView();
  } else {
    showMessage("Ability already used this round.");
  }
}
  
function applyDiceOutcome() {
  if (matchOver) return;

  const selected = document.getElementById('diceOutcomeSelect').value;
  if (!selected) {
	showMessage("Please select a Dice Roll outcome first!");
	return;
  }

  const roll = parseInt(selected);
  const player = currentTurn;
  const opponent = currentTurn === 1 ? 2 : 1;

  switch (roll) {
	case 1: // Health Gain
  	teamData[player].forEach(card => {
    	card.hp += 10;
  	});
  	showMessage("All your cards gained +10 HP!");
  	break;

	case 2: // Health Lost
  	teamData[opponent].forEach(card => {
    	card.hp = Math.max(0, card.hp - 10);
  	});
  	showMessage("Opponent‚Äôs team lost -10 HP!");
  	break;

	case 3: // Defense Break
  	const oppActive = teamData[opponent].find(card => card.active);
  	if (oppActive) {
    	if (oppActive.defense > 0) {
      	oppActive.defense = Math.max(0, oppActive.defense - 10);
      	showMessage("Defense Break! Opponent's Active Player defense reduced by 10.");
    	} else {
      	showMessage("No defense to break! You may add +10 bonus to your next attack.");
      	// Optional: Set a bonus attack flag here if you want later
    	}
  	}
  	break;

	case 4: // Defense Gain
  	const myActive = teamData[player].find(card => card.active);
  	if (myActive) {
    	myActive.defense += 10;
    	showMessage("Defense Gain! Your Active Player gained +10 defense.");
  	}
  	break;

	case 5: // Attack Swap
  	showMessage("Attack Swap! Use opponent's Active Player Basic Attack for your next attack.");
  	// Optional: Implement Attack Swap logic later
  	break;

	case 6: // Power Attack
  	showMessage("Power Boost! You may use Special Attack without action cards.");
  	// Optional: Flag Special Attack available next turn
  	break;
  }
    stats[currentTurn].diceRolls++;
  syncMatchToSupabase();
  updateGameplayView();
}      
      
</script>

    
<div class="screen" id="gameplayScreen" style="display:none;">
  <div id="roundTracker" style="margin-bottom: 20px;"></div>
  <h2 id="turnTitle">Player 1's Turn</h2>
  <div id="gameMessage" style="margin: 10px 0; min-height: 24px; font-size: 1em; color: #00f2ff;"></div>
  <div id="playerCards"></div>
  <div id="roundResultOptions" style="margin-top: 20px;">
  <h3>Round Result:</h3>
  <div class="radio-group">
	<label><input type="radio" name="roundResult" value="win"> I Won this Round</label>
	<label><input type="radio" name="roundResult" value="lose"> I Lost this Round</label>
  </div>
</div>
<div style="margin-top: 20px;">
	<button onclick="endRound()">End Round</button>
  </div>
 </div>

<div class="screen" id="winnerScreen" style="display:none;">
  <img src="https://static.wixstatic.com/media/7f810a_210d5ec4c8f34517b7eaf24df4658344~mv2.png" alt="Built for Battle Logo" style="max-width: 200px; margin-bottom: 20px;">
  <h1 id="finalWinnerName" style="margin-bottom: 20px;">Winner: TBD</h1>
  <div id="finalRoundResults" style="margin-bottom: 20px;"></div>
  <button onclick="endMatch()">Reset Match</button>
  <button onclick="showMatchSummary()">Match Summary</button>
</div>

<div class="screen" id="matchSummaryScreen" style="display:none;">
  <img src="https://static.wixstatic.com/media/7f810a_210d5ec4c8f34517b7eaf24df4658344~mv2.png" alt="Built for Battle Logo" style="max-width: 200px; margin-bottom: 20px;">
  <h1>Match Summary</h1>
  <div id="matchSummaryContent" style="margin-bottom: 20px;"></div>
  <button onclick="endMatch()">Play Again</button>
</div>

<div id="imageModal" style="display:none;" onclick="closeModal()">
  <img id="modalImage" src="" alt="Enlarged Image">
</div>
  
<script>
let currentRound = 1;
let hasSwappedThisTurn = false;
let matchOver = false;


function enlargeImage(src) {
  const modal = document.getElementById('imageModal');
  const modalImg = document.getElementById('modalImage');
  modalImg.src = src;
  modal.style.display = 'flex';
  document.body.style.overflow = 'hidden';

}

function closeModal() {
  document.getElementById('imageModal').style.display = 'none';
  document.body.style.overflow = '';
}
  
</script>
</body>
</html>
